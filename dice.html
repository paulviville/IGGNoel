<!DOCTYPE html>
<html>

	<head>
		<title>DÃ© Nero</title>
		<style>
			body { margin : 0; max-width: 100%; max-height: 100%; margin: 0;}
			canvas {width: 100%; height: 100%; max-width: 100%; max-height: 100%; margin: 0; display: block;}
		</style>
	</head>

	<body>
		<script src="./ammo.wasm.js"></script>

		<script type="module">
			import * as THREE from './three.module.js';
			import {OrbitControls} from './OrbitsControls.js';
			import { AmmoPhysics } from './AmmoPhysics.js';
			import Stats from './stats.module.js'

			let camera, scene, renderer, stats;
			let physics, position;

			let box, materials, geometryBox;

			init();

			async function init() {

				physics = await AmmoPhysics();
				position = new THREE.Vector3();

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0.5, 1, 0 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xDDDDDD );

				const hemiLight = new THREE.HemisphereLight();
				hemiLight.intensity = 0.35;
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight();
				dirLight.position.set( 5, 5, 5 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.zoom = 2;
				scene.add( dirLight );

				const floor = new THREE.Mesh(
					new THREE.BoxBufferGeometry( 2, 5, 2 ),
					new THREE.ShadowMaterial( { color: 0x111111 } )
				);
				floor.position.y = - 2.5;
				floor.receiveShadow = true;
				scene.add( floor );
				physics.addMesh( floor );

				let block = new THREE.Mesh(
					new THREE.BoxBufferGeometry( 10, 1, 1),
					new THREE.MeshBasicMaterial( { color: 0x111111 } )
				);
				block.position.z += 0.75
				// scene.add(block);
				physics.addMesh( block );

				block = new THREE.Mesh(
					new THREE.BoxBufferGeometry( 10, 1, 1),
					new THREE.MeshBasicMaterial( { color: 0x111111 } )
				);
				block.position.z -= 0.75
				// scene.add(block);
				physics.addMesh( block );

				block = new THREE.Mesh(
					new THREE.BoxBufferGeometry( 1, 1, 10),
					new THREE.MeshBasicMaterial( { color: 0x111111 } )
				);
				block.position.x -= 1
				// scene.add(block);
				physics.addMesh( block );

				// block = new THREE.Mesh(
				// 	new THREE.BoxBufferGeometry( 1, 1, 10),
				// 	new THREE.MeshBasicMaterial( { color: 0x111111 } )
				// );
				// block.position.x += 1
				// scene.add(block);
				// physics.addMesh( block );

				const material = new THREE.MeshLambertMaterial();

				const matrix = new THREE.Matrix4();
				const color = new THREE.Color();

				// Box
				const loader = new THREE.TextureLoader();

				materials = [
					new THREE.MeshLambertMaterial({map: loader.load('./Nero1.png')}),
					new THREE.MeshLambertMaterial({map: loader.load('./Nero2.png')}),
					new THREE.MeshLambertMaterial({map: loader.load('./Nero3.png')}),
					new THREE.MeshLambertMaterial({map: loader.load('./Nero4.png')}),
					new THREE.MeshLambertMaterial({map: loader.load('./Nero5.png')}),
					new THREE.MeshLambertMaterial({map: loader.load('./Nero6.png')}),
				];
				geometryBox = new THREE.BoxBufferGeometry( 0.2, 0.2, 0.2 );
				box = new THREE.Mesh( geometryBox, materials );
				box.castShadow = true;
				// box.receiveShadow = true;
				scene.add( box );
				physics.addMesh( box, 1 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );

				stats = new Stats();
				document.body.appendChild(stats.dom);

				//

				// const controls = new OrbitControls( camera, renderer.domElement );
				// controls.target.y = 0.5;
				// controls.update();
				position = new THREE.Vector3(10, 10, 0);
				physics.setMeshPosition( box, position);
				initInput()
				animate();

			}

			const mouseCoords = new THREE.Vector2();
			const raycaster = new THREE.Raycaster();
			function initInput() {
				// mousedown
				window.addEventListener( 'mousedown', function ( event ) {
					mouseCoords.set(
						( event.clientX / window.innerWidth ) * 2 - 1,
						- ( event.clientY / window.innerHeight ) * 2 + 1
					);

					raycaster.setFromCamera( mouseCoords, camera );

					position.copy( raycaster.ray.origin );

					let angular = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize().multiplyScalar(5);
					let dir = raycaster.ray.direction.clone();
					dir.z /= 2;

					scene.remove(box);
					physics.removeMesh(box);


				box = new THREE.Mesh( geometryBox, materials );
				box.castShadow = true;
				// box.receiveShadow = true;
				scene.add( box );
				physics.addMesh( box, 1 );


					physics.throwMesh( box, position, dir.multiplyScalar(2.75), angular);
					console.log(physics)



					materials.sort(function(a, b) {
						return Math.random() - Math.random();
					});
				} );

				window.addEventListener('resize', function() {
					const width = window.innerWidth;
					const height = window.innerHeight;
					renderer.setSize(width, height);
					camera.aspect = width / height;
					camera.updateProjectionMatrix();
				});

				function onDocumentTouchStart(event){
				// console.log("touch2")
				// event.preventDefault();
				event.clientX = event.touches[0].clientX;
				event.clientY = event.touches[0].clientY;
				event.buttons = 1;
				onMouseDown(event);
			}
			window.addEventListener( 'touchstart', onDocumentTouchStart, false );

			}

			function animate() {
				stats.update();
				requestAnimationFrame( animate );
				

				renderer.render( scene, camera );
			}
		</script>
	</body>

</html>